{"ast":null,"code":"/**\n * Module dependencies.\n */\nvar SourceMap = require('source-map').SourceMapGenerator;\n\nvar SourceMapConsumer = require('source-map').SourceMapConsumer;\n\nvar sourceMapResolve = require('source-map-resolve');\n\nvar urix = require('urix');\n\nvar fs = require('fs');\n\nvar path = require('path');\n/**\n * Expose `mixin()`.\n */\n\n\nmodule.exports = mixin;\n/**\n * Mixin source map support into `compiler`.\n *\n * @param {Compiler} compiler\n * @api public\n */\n\nfunction mixin(compiler) {\n  compiler._comment = compiler.comment;\n  compiler.map = new SourceMap();\n  compiler.position = {\n    line: 1,\n    column: 1\n  };\n  compiler.files = {};\n\n  for (var k in exports) {\n    compiler[k] = exports[k];\n  }\n}\n/**\n * Update position.\n *\n * @param {String} str\n * @api private\n */\n\n\nexports.updatePosition = function (str) {\n  var lines = str.match(/\\n/g);\n  if (lines) this.position.line += lines.length;\n  var i = str.lastIndexOf('\\n');\n  this.position.column = ~i ? str.length - i : this.position.column + str.length;\n};\n/**\n * Emit `str`.\n *\n * @param {String} str\n * @param {Object} [pos]\n * @return {String}\n * @api private\n */\n\n\nexports.emit = function (str, pos) {\n  if (pos) {\n    var sourceFile = urix(pos.source || 'source.css');\n    this.map.addMapping({\n      source: sourceFile,\n      generated: {\n        line: this.position.line,\n        column: Math.max(this.position.column - 1, 0)\n      },\n      original: {\n        line: pos.start.line,\n        column: pos.start.column - 1\n      }\n    });\n    this.addFile(sourceFile, pos);\n  }\n\n  this.updatePosition(str);\n  return str;\n};\n/**\n * Adds a file to the source map output if it has not already been added\n * @param {String} file\n * @param {Object} pos\n */\n\n\nexports.addFile = function (file, pos) {\n  if (typeof pos.content !== 'string') return;\n  if (Object.prototype.hasOwnProperty.call(this.files, file)) return;\n  this.files[file] = pos.content;\n};\n/**\n * Applies any original source maps to the output and embeds the source file\n * contents in the source map.\n */\n\n\nexports.applySourceMaps = function () {\n  Object.keys(this.files).forEach(function (file) {\n    var content = this.files[file];\n    this.map.setSourceContent(file, content);\n\n    if (this.options.inputSourcemaps !== false) {\n      var originalMap = sourceMapResolve.resolveSync(content, file, fs.readFileSync);\n\n      if (originalMap) {\n        var map = new SourceMapConsumer(originalMap.map);\n        var relativeTo = originalMap.sourcesRelativeTo;\n        this.map.applySourceMap(map, file, urix(path.dirname(relativeTo)));\n      }\n    }\n  }, this);\n};\n/**\n * Process comments, drops sourceMap comments.\n * @param {Object} node\n */\n\n\nexports.comment = function (node) {\n  if (/^# sourceMappingURL=/.test(node.comment)) return this.emit('', node.position);else return this._comment(node);\n};","map":null,"metadata":{},"sourceType":"script"}