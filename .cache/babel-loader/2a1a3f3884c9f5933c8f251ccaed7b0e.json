{"ast":null,"code":"var R = require('ramda');\n\nvar Rx = require('rx');\n/**\n * @param {Object} opts An options object\n * @param {String} [opts.displayName='SvgReactComponent'] A displayName to use\n * for the generated React Component\n * @param {Object} [opts.root] An alternative root node\n * @param {String} [opts.root.tagname]\n * @param {Object} [opts.root.props]\n * @param {Function[]} [opts.filters] List of additional filters to use when\n * traversing the object tree generated from the SVG\n * @param {Object} [opts.propsMap={'for':'htmlFor','class':'className'}] Hash of\n * prop name mappings\n * @param {String} [opts.classIdPrefix=false] String to use as a prefix for all\n * class and id selectors in any style nodes or className props found\n * @param {Boolean} [opts.raw=false] If set to `true` will output the parsed\n * object tree repesenting the SVG as a JSON string. Otherwise, returns a string\n * of JavaScript that represents the component's module.\n * @param {RegExp} [opts.xmlnsTest=/^xmlns(Xlink)?$/] The regular expression\n * used to find and remove xmlns type props\n * @param {String|Object} source The SVG source, or an object tree representing\n * the SVG\n * @returns {Rx.Observable<String|Object>}\n */\n\n\nvar pickStringifyOpts = R.pick(['displayName']);\nvar pickSanitizeOpts = R.pick(['filters']);\nmodule.exports = R.curry(function svgToReact(opts, source) {\n  var options = require('./options')(opts);\n\n  var stringify = require('./component/stringify')(pickStringifyOpts(options));\n\n  var sanitize = require('./sanitize')(pickSanitizeOpts(options));\n\n  var parse = require('./xml/parse')(null);\n\n  var tree = Rx.Observable.defer(function () {\n    return Rx.Observable.just(JSON.parse(source));\n  }).catch(function () {\n    // console.warn('Couldn\\'t parse with JSON. Trying xml...');\n    return parse(source);\n  }).map(sanitize);\n  return options.raw ? tree.map(JSON.stringify.bind(JSON)) : tree.map(stringify);\n});","map":null,"metadata":{},"sourceType":"script"}