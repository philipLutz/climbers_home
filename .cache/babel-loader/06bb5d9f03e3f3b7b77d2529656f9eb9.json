{"ast":null,"code":"var R = require('ramda');\n\nvar css = require('css');\n\nvar DEFAULTS = {\n  prefix: 'filename-prefix__',\n  tagKey: 'tagname',\n  styleTagKey: 'style',\n  childrenKey: 'children'\n};\nvar CLASSNAME_OR_ID_REGEX = /([a-zA-Z0-9_-]+)/g;\nvar CLASSNAME_OR_ID_SELECTOR_REGEX = /([.#])([a-zA-Z0-9_-]+)/g;\n\nfunction processStyles(opts, source) {\n  var ast = css.parse(source);\n  var rules = ast.stylesheet.rules;\n  rules.forEach(function (rule) {\n    var selectors = rule.selectors;\n    rule.selectors = selectors.map(function (sel) {\n      return sel.replace(CLASSNAME_OR_ID_SELECTOR_REGEX, function (match, pre, post) {\n        opts.cache[post] = opts.prefix + post;\n        return pre + opts.prefix + post;\n      });\n    });\n  });\n  return css.stringify(ast, {\n    compress: true\n  });\n}\n\nmodule.exports = function configrePrefixStyleClassId(opts) {\n  var options = R.merge(DEFAULTS, opts || {});\n  var cache = options.cache = {};\n  var tagKey = options.tagKey;\n  var styleTagKey = options.styleTagKey;\n  var childrenKey = options.childrenKey;\n  var hasChildrenKey = R.has(childrenKey);\n  var isStyleNode = R.where(R.objOf(tagKey, R.equals(styleTagKey)));\n  return function prefixStyleClassId(value) {\n    var path = this.path;\n    var isStyle = isStyleNode(value);\n    var hasChildren = hasChildrenKey(value);\n\n    if (this.notLeaf && isStyle && hasChildren) {\n      value.children = value.children.map(function (child) {\n        if (typeof child === 'string') {\n          return processStyles(options, child);\n        }\n\n        return child;\n      });\n    } else if (this.isLeaf && path[path.length - 1] === 'className') {\n      this.update(value.replace(CLASSNAME_OR_ID_REGEX, function (m) {\n        if (m in cache) {\n          return cache[m];\n        }\n\n        return m;\n      }));\n    }\n  };\n};","map":null,"metadata":{},"sourceType":"script"}