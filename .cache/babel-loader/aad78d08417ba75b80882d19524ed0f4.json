{"ast":null,"code":"// json5.js\n// Modern JSON. See README.md for details.\n//\n// This file is based directly off of Douglas Crockford's json_parse.js:\n// https://github.com/douglascrockford/JSON-js/blob/master/json_parse.js\nvar JSON5 = typeof exports === 'object' ? exports : {};\n\nJSON5.parse = function () {\n  \"use strict\"; // This is a function that can parse a JSON5 text, producing a JavaScript\n  // data structure. It is a simple, recursive descent parser. It does not use\n  // eval or regular expressions, so it can be used as a model for implementing\n  // a JSON5 parser in other languages.\n  // We are defining the function inside of another function to avoid creating\n  // global variables.\n\n  var at,\n      // The index of the current character\n  lineNumber,\n      // The current line number\n  columnNumber,\n      // The current column number\n  ch,\n      // The current character\n  escapee = {\n    \"'\": \"'\",\n    '\"': '\"',\n    '\\\\': '\\\\',\n    '/': '/',\n    '\\n': '',\n    // Replace escaped newlines in strings w/ empty string\n    b: '\\b',\n    f: '\\f',\n    n: '\\n',\n    r: '\\r',\n    t: '\\t'\n  },\n      ws = [' ', '\\t', '\\r', '\\n', '\\v', '\\f', '\\xA0', \"\\uFEFF\"],\n      text,\n      renderChar = function renderChar(chr) {\n    return chr === '' ? 'EOF' : \"'\" + chr + \"'\";\n  },\n      error = function error(m) {\n    // Call error when something is wrong.\n    var error = new SyntaxError(); // beginning of message suffix to agree with that provided by Gecko - see https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/JSON/parse\n\n    error.message = m + \" at line \" + lineNumber + \" column \" + columnNumber + \" of the JSON5 data. Still to read: \" + JSON.stringify(text.substring(at - 1, at + 19));\n    error.at = at; // These two property names have been chosen to agree with the ones in Gecko, the only popular\n    // environment which seems to supply this info on JSON.parse\n\n    error.lineNumber = lineNumber;\n    error.columnNumber = columnNumber;\n    throw error;\n  },\n      next = function next(c) {\n    // If a c parameter is provided, verify that it matches the current character.\n    if (c && c !== ch) {\n      error(\"Expected \" + renderChar(c) + \" instead of \" + renderChar(ch));\n    } // Get the next character. When there are no more characters,\n    // return the empty string.\n\n\n    ch = text.charAt(at);\n    at++;\n    columnNumber++;\n\n    if (ch === '\\n' || ch === '\\r' && peek() !== '\\n') {\n      lineNumber++;\n      columnNumber = 0;\n    }\n\n    return ch;\n  },\n      peek = function peek() {\n    // Get the next character without consuming it or\n    // assigning it to the ch varaible.\n    return text.charAt(at);\n  },\n      identifier = function identifier() {\n    // Parse an identifier. Normally, reserved words are disallowed here, but we\n    // only use this for unquoted object keys, where reserved words are allowed,\n    // so we don't check for those here. References:\n    // - http://es5.github.com/#x7.6\n    // - https://developer.mozilla.org/en/Core_JavaScript_1.5_Guide/Core_Language_Features#Variables\n    // - http://docstore.mik.ua/orelly/webprog/jscript/ch02_07.htm\n    // TODO Identifiers can have Unicode \"letters\" in them; add support for those.\n    var key = ch; // Identifiers must start with a letter, _ or $.\n\n    if (ch !== '_' && ch !== '$' && (ch < 'a' || ch > 'z') && (ch < 'A' || ch > 'Z')) {\n      error(\"Bad identifier as unquoted key\");\n    } // Subsequent characters can contain digits.\n\n\n    while (next() && (ch === '_' || ch === '$' || ch >= 'a' && ch <= 'z' || ch >= 'A' && ch <= 'Z' || ch >= '0' && ch <= '9')) {\n      key += ch;\n    }\n\n    return key;\n  },\n      number = function number() {\n    // Parse a number value.\n    var number,\n        sign = '',\n        string = '',\n        base = 10;\n\n    if (ch === '-' || ch === '+') {\n      sign = ch;\n      next(ch);\n    } // support for Infinity (could tweak to allow other words):\n\n\n    if (ch === 'I') {\n      number = word();\n\n      if (typeof number !== 'number' || isNaN(number)) {\n        error('Unexpected word for number');\n      }\n\n      return sign === '-' ? -number : number;\n    } // support for NaN\n\n\n    if (ch === 'N') {\n      number = word();\n\n      if (!isNaN(number)) {\n        error('expected word to be NaN');\n      } // ignore sign as -NaN also is NaN\n\n\n      return number;\n    }\n\n    if (ch === '0') {\n      string += ch;\n      next();\n\n      if (ch === 'x' || ch === 'X') {\n        string += ch;\n        next();\n        base = 16;\n      } else if (ch >= '0' && ch <= '9') {\n        error('Octal literal');\n      }\n    }\n\n    switch (base) {\n      case 10:\n        while (ch >= '0' && ch <= '9') {\n          string += ch;\n          next();\n        }\n\n        if (ch === '.') {\n          string += '.';\n\n          while (next() && ch >= '0' && ch <= '9') {\n            string += ch;\n          }\n        }\n\n        if (ch === 'e' || ch === 'E') {\n          string += ch;\n          next();\n\n          if (ch === '-' || ch === '+') {\n            string += ch;\n            next();\n          }\n\n          while (ch >= '0' && ch <= '9') {\n            string += ch;\n            next();\n          }\n        }\n\n        break;\n\n      case 16:\n        while (ch >= '0' && ch <= '9' || ch >= 'A' && ch <= 'F' || ch >= 'a' && ch <= 'f') {\n          string += ch;\n          next();\n        }\n\n        break;\n    }\n\n    if (sign === '-') {\n      number = -string;\n    } else {\n      number = +string;\n    }\n\n    if (!isFinite(number)) {\n      error(\"Bad number\");\n    } else {\n      return number;\n    }\n  },\n      string = function string() {\n    // Parse a string value.\n    var hex,\n        i,\n        string = '',\n        delim,\n        // double quote or single quote\n    uffff; // When parsing for string values, we must look for ' or \" and \\ characters.\n\n    if (ch === '\"' || ch === \"'\") {\n      delim = ch;\n\n      while (next()) {\n        if (ch === delim) {\n          next();\n          return string;\n        } else if (ch === '\\\\') {\n          next();\n\n          if (ch === 'u') {\n            uffff = 0;\n\n            for (i = 0; i < 4; i += 1) {\n              hex = parseInt(next(), 16);\n\n              if (!isFinite(hex)) {\n                break;\n              }\n\n              uffff = uffff * 16 + hex;\n            }\n\n            string += String.fromCharCode(uffff);\n          } else if (ch === '\\r') {\n            if (peek() === '\\n') {\n              next();\n            }\n          } else if (typeof escapee[ch] === 'string') {\n            string += escapee[ch];\n          } else {\n            break;\n          }\n        } else if (ch === '\\n') {\n          // unescaped newlines are invalid; see:\n          // https://github.com/aseemk/json5/issues/24\n          // TODO this feels special-cased; are there other\n          // invalid unescaped chars?\n          break;\n        } else {\n          string += ch;\n        }\n      }\n    }\n\n    error(\"Bad string\");\n  },\n      inlineComment = function inlineComment() {\n    // Skip an inline comment, assuming this is one. The current character should\n    // be the second / character in the // pair that begins this inline comment.\n    // To finish the inline comment, we look for a newline or the end of the text.\n    if (ch !== '/') {\n      error(\"Not an inline comment\");\n    }\n\n    do {\n      next();\n\n      if (ch === '\\n' || ch === '\\r') {\n        next();\n        return;\n      }\n    } while (ch);\n  },\n      blockComment = function blockComment() {\n    // Skip a block comment, assuming this is one. The current character should be\n    // the * character in the /* pair that begins this block comment.\n    // To finish the block comment, we look for an ending */ pair of characters,\n    // but we also watch for the end of text before the comment is terminated.\n    if (ch !== '*') {\n      error(\"Not a block comment\");\n    }\n\n    do {\n      next();\n\n      while (ch === '*') {\n        next('*');\n\n        if (ch === '/') {\n          next('/');\n          return;\n        }\n      }\n    } while (ch);\n\n    error(\"Unterminated block comment\");\n  },\n      comment = function comment() {\n    // Skip a comment, whether inline or block-level, assuming this is one.\n    // Comments always begin with a / character.\n    if (ch !== '/') {\n      error(\"Not a comment\");\n    }\n\n    next('/');\n\n    if (ch === '/') {\n      inlineComment();\n    } else if (ch === '*') {\n      blockComment();\n    } else {\n      error(\"Unrecognized comment\");\n    }\n  },\n      white = function white() {\n    // Skip whitespace and comments.\n    // Note that we're detecting comments by only a single / character.\n    // This works since regular expressions are not valid JSON(5), but this will\n    // break if there are other valid values that begin with a / character!\n    while (ch) {\n      if (ch === '/') {\n        comment();\n      } else if (ws.indexOf(ch) >= 0) {\n        next();\n      } else {\n        return;\n      }\n    }\n  },\n      word = function word() {\n    // true, false, or null.\n    switch (ch) {\n      case 't':\n        next('t');\n        next('r');\n        next('u');\n        next('e');\n        return true;\n\n      case 'f':\n        next('f');\n        next('a');\n        next('l');\n        next('s');\n        next('e');\n        return false;\n\n      case 'n':\n        next('n');\n        next('u');\n        next('l');\n        next('l');\n        return null;\n\n      case 'I':\n        next('I');\n        next('n');\n        next('f');\n        next('i');\n        next('n');\n        next('i');\n        next('t');\n        next('y');\n        return Infinity;\n\n      case 'N':\n        next('N');\n        next('a');\n        next('N');\n        return NaN;\n    }\n\n    error(\"Unexpected \" + renderChar(ch));\n  },\n      value,\n      // Place holder for the value function.\n  array = function array() {\n    // Parse an array value.\n    var array = [];\n\n    if (ch === '[') {\n      next('[');\n      white();\n\n      while (ch) {\n        if (ch === ']') {\n          next(']');\n          return array; // Potentially empty array\n        } // ES5 allows omitting elements in arrays, e.g. [,] and\n        // [,null]. We don't allow this in JSON5.\n\n\n        if (ch === ',') {\n          error(\"Missing array element\");\n        } else {\n          array.push(value());\n        }\n\n        white(); // If there's no comma after this value, this needs to\n        // be the end of the array.\n\n        if (ch !== ',') {\n          next(']');\n          return array;\n        }\n\n        next(',');\n        white();\n      }\n    }\n\n    error(\"Bad array\");\n  },\n      object = function object() {\n    // Parse an object value.\n    var key,\n        object = {};\n\n    if (ch === '{') {\n      next('{');\n      white();\n\n      while (ch) {\n        if (ch === '}') {\n          next('}');\n          return object; // Potentially empty object\n        } // Keys can be unquoted. If they are, they need to be\n        // valid JS identifiers.\n\n\n        if (ch === '\"' || ch === \"'\") {\n          key = string();\n        } else {\n          key = identifier();\n        }\n\n        white();\n        next(':');\n        object[key] = value();\n        white(); // If there's no comma after this pair, this needs to be\n        // the end of the object.\n\n        if (ch !== ',') {\n          next('}');\n          return object;\n        }\n\n        next(',');\n        white();\n      }\n    }\n\n    error(\"Bad object\");\n  };\n\n  value = function value() {\n    // Parse a JSON value. It could be an object, an array, a string, a number,\n    // or a word.\n    white();\n\n    switch (ch) {\n      case '{':\n        return object();\n\n      case '[':\n        return array();\n\n      case '\"':\n      case \"'\":\n        return string();\n\n      case '-':\n      case '+':\n      case '.':\n        return number();\n\n      default:\n        return ch >= '0' && ch <= '9' ? number() : word();\n    }\n  }; // Return the json_parse function. It will have access to all of the above\n  // functions and variables.\n\n\n  return function (source, reviver) {\n    var result;\n    text = String(source);\n    at = 0;\n    lineNumber = 1;\n    columnNumber = 1;\n    ch = ' ';\n    result = value();\n    white();\n\n    if (ch) {\n      error(\"Syntax error\");\n    } // If there is a reviver function, we recursively walk the new structure,\n    // passing each name/value pair to the reviver function for possible\n    // transformation, starting with a temporary root object that holds the result\n    // in an empty key. If there is not a reviver function, we simply return the\n    // result.\n\n\n    return typeof reviver === 'function' ? function walk(holder, key) {\n      var k,\n          v,\n          value = holder[key];\n\n      if (value && typeof value === 'object') {\n        for (k in value) {\n          if (Object.prototype.hasOwnProperty.call(value, k)) {\n            v = walk(value, k);\n\n            if (v !== undefined) {\n              value[k] = v;\n            } else {\n              delete value[k];\n            }\n          }\n        }\n      }\n\n      return reviver.call(holder, key, value);\n    }({\n      '': result\n    }, '') : result;\n  };\n}(); // JSON5 stringify will not quote keys where appropriate\n\n\nJSON5.stringify = function (obj, replacer, space) {\n  if (replacer && typeof replacer !== \"function\" && !isArray(replacer)) {\n    throw new Error('Replacer must be a function or an array');\n  }\n\n  var getReplacedValueOrUndefined = function getReplacedValueOrUndefined(holder, key, isTopLevel) {\n    var value = holder[key]; // Replace the value with its toJSON value first, if possible\n\n    if (value && value.toJSON && typeof value.toJSON === \"function\") {\n      value = value.toJSON();\n    } // If the user-supplied replacer if a function, call it. If it's an array, check objects' string keys for\n    // presence in the array (removing the key/value pair from the resulting JSON if the key is missing).\n\n\n    if (typeof replacer === \"function\") {\n      return replacer.call(holder, key, value);\n    } else if (replacer) {\n      if (isTopLevel || isArray(holder) || replacer.indexOf(key) >= 0) {\n        return value;\n      } else {\n        return undefined;\n      }\n    } else {\n      return value;\n    }\n  };\n\n  function isWordChar(c) {\n    return c >= 'a' && c <= 'z' || c >= 'A' && c <= 'Z' || c >= '0' && c <= '9' || c === '_' || c === '$';\n  }\n\n  function isWordStart(c) {\n    return c >= 'a' && c <= 'z' || c >= 'A' && c <= 'Z' || c === '_' || c === '$';\n  }\n\n  function isWord(key) {\n    if (typeof key !== 'string') {\n      return false;\n    }\n\n    if (!isWordStart(key[0])) {\n      return false;\n    }\n\n    var i = 1,\n        length = key.length;\n\n    while (i < length) {\n      if (!isWordChar(key[i])) {\n        return false;\n      }\n\n      i++;\n    }\n\n    return true;\n  } // export for use in tests\n\n\n  JSON5.isWord = isWord; // polyfills\n\n  function isArray(obj) {\n    if (Array.isArray) {\n      return Array.isArray(obj);\n    } else {\n      return Object.prototype.toString.call(obj) === '[object Array]';\n    }\n  }\n\n  function isDate(obj) {\n    return Object.prototype.toString.call(obj) === '[object Date]';\n  }\n\n  var objStack = [];\n\n  function checkForCircular(obj) {\n    for (var i = 0; i < objStack.length; i++) {\n      if (objStack[i] === obj) {\n        throw new TypeError(\"Converting circular structure to JSON\");\n      }\n    }\n  }\n\n  function makeIndent(str, num, noNewLine) {\n    if (!str) {\n      return \"\";\n    } // indentation no more than 10 chars\n\n\n    if (str.length > 10) {\n      str = str.substring(0, 10);\n    }\n\n    var indent = noNewLine ? \"\" : \"\\n\";\n\n    for (var i = 0; i < num; i++) {\n      indent += str;\n    }\n\n    return indent;\n  }\n\n  var indentStr;\n\n  if (space) {\n    if (typeof space === \"string\") {\n      indentStr = space;\n    } else if (typeof space === \"number\" && space >= 0) {\n      indentStr = makeIndent(\" \", space, true);\n    } else {// ignore space parameter\n    }\n  } // Copied from Crokford's implementation of JSON\n  // See https://github.com/douglascrockford/JSON-js/blob/e39db4b7e6249f04a195e7dd0840e610cc9e941e/json2.js#L195\n  // Begin\n\n\n  var cx = /[\\u0000\\u00ad\\u0600-\\u0604\\u070f\\u17b4\\u17b5\\u200c-\\u200f\\u2028-\\u202f\\u2060-\\u206f\\ufeff\\ufff0-\\uffff]/g,\n      escapable = /[\\\\\\\"\\x00-\\x1f\\x7f-\\x9f\\u00ad\\u0600-\\u0604\\u070f\\u17b4\\u17b5\\u200c-\\u200f\\u2028-\\u202f\\u2060-\\u206f\\ufeff\\ufff0-\\uffff]/g,\n      meta = {\n    // table of character substitutions\n    '\\b': '\\\\b',\n    '\\t': '\\\\t',\n    '\\n': '\\\\n',\n    '\\f': '\\\\f',\n    '\\r': '\\\\r',\n    '\"': '\\\\\"',\n    '\\\\': '\\\\\\\\'\n  };\n\n  function escapeString(string) {\n    // If the string contains no control characters, no quote characters, and no\n    // backslash characters, then we can safely slap some quotes around it.\n    // Otherwise we must also replace the offending characters with safe escape\n    // sequences.\n    escapable.lastIndex = 0;\n    return escapable.test(string) ? '\"' + string.replace(escapable, function (a) {\n      var c = meta[a];\n      return typeof c === 'string' ? c : \"\\\\u\" + ('0000' + a.charCodeAt(0).toString(16)).slice(-4);\n    }) + '\"' : '\"' + string + '\"';\n  } // End\n\n\n  function internalStringify(holder, key, isTopLevel) {\n    var buffer, res; // Replace the value, if necessary\n\n    var obj_part = getReplacedValueOrUndefined(holder, key, isTopLevel);\n\n    if (obj_part && !isDate(obj_part)) {\n      // unbox objects\n      // don't unbox dates, since will turn it into number\n      obj_part = obj_part.valueOf();\n    }\n\n    switch (typeof obj_part) {\n      case \"boolean\":\n        return obj_part.toString();\n\n      case \"number\":\n        if (isNaN(obj_part) || !isFinite(obj_part)) {\n          return \"null\";\n        }\n\n        return obj_part.toString();\n\n      case \"string\":\n        return escapeString(obj_part.toString());\n\n      case \"object\":\n        if (obj_part === null) {\n          return \"null\";\n        } else if (isArray(obj_part)) {\n          checkForCircular(obj_part);\n          buffer = \"[\";\n          objStack.push(obj_part);\n\n          for (var i = 0; i < obj_part.length; i++) {\n            res = internalStringify(obj_part, i, false);\n            buffer += makeIndent(indentStr, objStack.length);\n\n            if (res === null || typeof res === \"undefined\") {\n              buffer += \"null\";\n            } else {\n              buffer += res;\n            }\n\n            if (i < obj_part.length - 1) {\n              buffer += \",\";\n            } else if (indentStr) {\n              buffer += \"\\n\";\n            }\n          }\n\n          objStack.pop();\n\n          if (obj_part.length) {\n            buffer += makeIndent(indentStr, objStack.length, true);\n          }\n\n          buffer += \"]\";\n        } else {\n          checkForCircular(obj_part);\n          buffer = \"{\";\n          var nonEmpty = false;\n          objStack.push(obj_part);\n\n          for (var prop in obj_part) {\n            if (obj_part.hasOwnProperty(prop)) {\n              var value = internalStringify(obj_part, prop, false);\n              isTopLevel = false;\n\n              if (typeof value !== \"undefined\" && value !== null) {\n                buffer += makeIndent(indentStr, objStack.length);\n                nonEmpty = true;\n                key = isWord(prop) ? prop : escapeString(prop);\n                buffer += key + \":\" + (indentStr ? ' ' : '') + value + \",\";\n              }\n            }\n          }\n\n          objStack.pop();\n\n          if (nonEmpty) {\n            buffer = buffer.substring(0, buffer.length - 1) + makeIndent(indentStr, objStack.length) + \"}\";\n          } else {\n            buffer = '{}';\n          }\n        }\n\n        return buffer;\n\n      default:\n        // functions and undefined should be ignored\n        return undefined;\n    }\n  } // special case...when undefined is used inside of\n  // a compound object/array, return null.\n  // but when top-level, return undefined\n\n\n  var topLevelHolder = {\n    \"\": obj\n  };\n\n  if (obj === undefined) {\n    return getReplacedValueOrUndefined(topLevelHolder, '', true);\n  }\n\n  return internalStringify(topLevelHolder, '', true);\n};","map":null,"metadata":{},"sourceType":"script"}